<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MapTemplate Viewer</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  
  <!-- Leaflet Draw CSS -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
  />

  <style>
    body, html { margin: 0; height: 100%; }
    #map        { width: 100%; height: 100%; }
    #header     { position:fixed; top:0; left:0; right:0; height:40px; background:#fff; box-shadow:0 2px 4px rgba(0,0,0,0.1); z-index:1001; padding:0 20px; display:flex; align-items:center; }
    #toolbar    { position:absolute; top:48px; left:8px; z-index:1000; background:#fff; padding:6px 10px; border-radius:4px; box-shadow:0 0 6px #0003;}
    #toolbar input{ width:90px }
    #error      { color:#d00; font-size:0.8rem }
    #drawingPanel { position:absolute; top:8px; right:8px; z-index:1000; background:#fff; padding:8px; border-radius:4px; box-shadow:0 0 6px #0003; }
    #drawingPanel button { margin:2px; padding:4px 8px; border:1px solid #ccc; background:#f8f9fa; cursor:pointer; border-radius:3px; }
    #drawingPanel button:hover { background:#e9ecef; }
    #drawingPanel button.active { background:#007bff; color:white; }
    .draw-status { font-size:0.85em; color:#666; margin-top:4px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div style="margin-bottom: 8px;">
      <input id="tokenInput" placeholder="Bearer Token" style="width: 300px; padding: 4px; font-size: 0.85em;" type="password" />
      <button id="btnSetToken" style="padding: 4px 8px;">Set Token</button>
    </div>
    <div style="margin-bottom: 8px;">
      <select id="templateSelect" style="width: 200px; padding: 4px;">
        <option value="">Loading templates...</option>
      </select>
    <button id="btnLoad">Load Template</button>
    </div>
    <div style="margin-bottom: 4px;">
      Template ID: <input id="templateId" value="" style="width: 60px;" />
    </div>
    <div style="margin-bottom: 8px;">
      <input id="mapId" placeholder="Map ID (for existing map)" style="width: 200px; padding: 4px;" />
      <button id="btnLoadMap">Load Map</button>
    </div>
    <div style="margin-bottom: 4px;">
      <button id="btnSaveState">Save State</button>
      <button id="btnClearState">Clear State</button>
    </div>
    <span id="error"></span>
  </div>



  <!-- Drawing Tools Panel -->
  <div id="drawingPanel">
    <div><strong>üñäÔ∏è Drawing Tools</strong></div>
    <div style="margin: 8px 0;">
      <button id="drawPoint">üìç Pin</button>
      <button id="drawLine">üìè Line</button>
      <button id="drawPolygon">üî∑ Polygon</button>
      <button id="drawCircle">‚≠ï Circle</button>
    </div>
    <div style="margin: 8px 0;">
      <button id="drawMarker">üè∑Ô∏è Marker</button>
      <button id="drawText">üìù Text</button>
      <button id="drawNote">üìã Note</button>
    </div>
    <div style="margin: 8px 0;">
      <button id="drawHighlighter">üñçÔ∏è Highlighter</button>
      <button id="drawRoute">üõ£Ô∏è Route</button>
      <button id="drawLink">üîó Link</button>
      <button id="drawVideo">üìπ Video</button>
    </div>
    <div style="margin: 8px 0;">
      <button id="editMode">‚úèÔ∏è Edit</button>
      <button id="deleteMode">üóëÔ∏è Delete</button>
      <button id="clearAll">üßπ Clear</button>
    </div>
    <div class="draw-status" id="drawStatus">Ready to draw</div>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <!-- Leaflet Draw JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  

  <script>
    const apiBase = "https://localhost:7099";      // ‚≠ê URL g·ªëc API c·ªßa b·∫°n
    // ‚≠ê L·∫•y token t·ª´ localStorage n·∫øu c√≥
    let token = localStorage.getItem('apiToken') || "";

    // Global variables
    let currentMapId = null;
    let currentLayerId = null;
    let drawingMode = null;
    let drawnItems = new L.FeatureGroup();
    
    // Free drawing variables
    let isDrawingHighlighter = false;
    let isDrawingRoute = false;
    let currentFreePath = [];
    let tempFreeLine = null;

    // kh·ªüi t·∫°o map
    const map = L.map("map").setView([16.0471, 108.2062], 6); // VN center
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);
    
    // Add drawn items layer to map
    map.addLayer(drawnItems);

    // style polygon m·∫∑c ƒë·ªãnh
    const polygonStyle = {
      color: "#3388ff",
      weight: 2,
      fillColor: "#3388ff",
      fillOpacity: 0.2,
    };

    // Drawing styles
    const drawingStyles = {
      pin: { color: "#ff0000", fillColor: "#ff0000", fillOpacity: 0.8, radius: 8 },
      line: { color: "#ff6600", weight: 3 },
      polygon: { color: "#00aa00", weight: 2, fillColor: "#00aa00", fillOpacity: 0.3 },
      circle: { color: "#9900cc", weight: 2, fillColor: "#9900cc", fillOpacity: 0.3 },
      marker: { color: "#ffcc00", fillColor: "#ffcc00", fillOpacity: 0.8 },
      text: { color: "#333333", fillColor: "#ffffff", fillOpacity: 0.9 },
      note: { color: "#0066cc", fillColor: "#e6f3ff", fillOpacity: 0.9 },
      highlighter: { color: "#ffff00", weight: 8, opacity: 0.6 },
      route: { color: "#ff0066", weight: 4, opacity: 0.8, dashArray: "10,5" },
      link: { color: "#0066ff", fillColor: "#0066ff", fillOpacity: 0.9, radius: 10 },
      video: { color: "#cc0066", fillColor: "#cc0066", fillOpacity: 0.9, radius: 12 }
    };

    // State Management Functions
    function saveMapState() {
      const state = {
        currentMapId: currentMapId,
        currentLayerId: currentLayerId,
        timestamp: Date.now()
      };
      localStorage.setItem('mapDrawingState', JSON.stringify(state));
      console.log('üíæ State saved:', state);
    }

    function loadMapState() {
      try {
        const saved = localStorage.getItem('mapDrawingState');
        if (saved) {
          const state = JSON.parse(saved);
          console.log('üìÇ State loaded:', state);
          return state;
        }
      } catch (error) {
        console.error('‚ùå Error loading state:', error);
      }
      return null;
    }

    function clearMapState() {
      localStorage.removeItem('mapDrawingState');
      console.log('üóëÔ∏è State cleared');
    }

    // API Helper Functions
    async function loadMapById(mapId) {
      try {
        console.log('üîÑ Loading map by ID:', mapId);
        
        const response = await fetch(`${apiBase}/api/v1/maps/${mapId}`, {
          headers: token ? { Authorization: `Bearer ${token}` } : {}
        });

        if (response.ok) {
          const responseData = await response.json();
          const mapData = responseData.map; // GetMapByIdResponse has "map" property
          console.log('‚úÖ Map loaded:', mapData);
          
          // Set current map context
          currentMapId = mapId;
          currentLayerId = mapData.layers && mapData.layers.length > 0 ? mapData.layers[0].id : null;
          
          // Clear existing layers
          if (window._allLayers) {
            window._allLayers.forEach(layer => map.removeLayer(layer));
            window._allLayers = [];
          } else {
            window._allLayers = [];
          }
          
          // Load map layers (if any)
          if (mapData.layers && mapData.layers.length > 0) {
            for (const layerInfo of mapData.layers) {
              try {
                // This might need adjustment based on actual API response structure
                if (layerInfo.layerData) {
                  const geoJsonData = JSON.parse(layerInfo.layerData);
                  const geoLayer = L.geoJSON(geoJsonData, {
                    style: layerInfo.layerStyle ? JSON.parse(layerInfo.layerStyle) : polygonStyle
                  }).addTo(map);
                  window._allLayers.push(geoLayer);
                }
              } catch (e) {
                console.warn('‚ùå Error loading layer:', e);
              }
            }
          }
          
          // Load existing features
          await loadMapFeatures(mapId);
          
          // Update UI
          document.getElementById('mapId').value = mapId;
          document.getElementById('error').textContent = '';
          document.getElementById('error').style.color = '#28a745';
          document.getElementById('error').textContent = `‚úÖ Map loaded: ${mapData.name || 'Unnamed Map'}`;
          
          // Save state
          saveMapState();
          
          return mapData;
        } else {
          const errorText = await response.text();
          console.error('‚ùå Failed to load map:', response.status, errorText);
          document.getElementById('error').textContent = `Failed to load map: ${response.status}`;
          return null;
        }
      } catch (error) {
        console.error('‚ùå Error loading map:', error);
        document.getElementById('error').textContent = `Error: ${error.message}`;
        return null;
      }
    }

    async function createMapFromTemplate(templateId, templateName) {
      try {
        console.log('üîÑ Creating map from template:', templateId);
        
        const response = await fetch(`${apiBase}/api/v1/maps/from-template`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { Authorization: `Bearer ${token}` } : {})
          },
          body: JSON.stringify({
            TemplateId: templateId,
            CustomName: `My ${templateName}`,
            CustomDescription: 'Map created for drawing features',
            IsPublic: false
          })
        });

        if (response.ok) {
          const newMap = await response.json();
          currentMapId = newMap.MapId || newMap.mapId;
          console.log('‚úÖ Map created successfully:', newMap);
          
          // Save state after creating map
          saveMapState();
          
          return newMap;
        } else {
          const errorText = await response.text();
          console.error('‚ùå Failed to create map:', response.status, errorText);
          // Fallback: use template ID as map ID (might not work for saving features)
          currentMapId = templateId;
          return null;
        }
      } catch (error) {
        console.error('‚ùå Error creating map:', error);
        // Fallback: use template ID as map ID
        currentMapId = templateId;
        return null;
      }
    }

    // Helper function to format feature data according to new API format
    function formatFeatureData(layer, name, geometryType, properties = {}) {
      let coordinates = [];
      let geoType = geometryType;
      
      if (layer instanceof L.CircleMarker || layer instanceof L.Marker) {
        const latlng = layer.getLatLng();
        coordinates = [latlng.lng, latlng.lat];
        geoType = "Point";
      } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        coordinates = layer.getLatLngs().map(ll => [ll.lng, ll.lat]);
        geoType = "LineString";
      } else if (layer instanceof L.Polygon) {
        coordinates = [layer.getLatLngs()[0].map(ll => [ll.lng, ll.lat])];
        geoType = "Polygon";
      } else if (layer instanceof L.Circle) {
        const latlng = layer.getLatLng();
        coordinates = [latlng.lng, latlng.lat];
        geoType = "Point";
        properties.radius = layer.getRadius();
      }

      return {
        name: name,
        project_id: currentMapId,
        style: {
          "fill-color": "#dc3c6e",
          "fill-opacity": 0.5,
          "fill-visible": true,
          "fill-field": null,
          "fill-color-scale": "quantize",
          "fill-extrusion-color": "#dc3c6e",
          "fill-extrusion-opacity": 0.5,
          "outline-color": "#dc3c6e",
          "outline-opacity": 1,
          "outline-visible": true,
          "outline-field": null,
          "outline-width": 2,
          "outline-dasharray": ["literal", [1]],
          "outline-color-scale": "quantize",
          "line-color": "#dc3c6e",
          "line-opacity": 1,
          "line-width": 2,
          "line-dasharray": ["literal", [1]],
          "line-cap": "butt",
          "circle-color": "#dc3c6e",
          "circle-opacity": 0.5,
          "circle-stroke-color": "#dc3c6e",
          "circle-stroke-opacity": 1,
          "circle-stroke-width": 2
        },
        geometries: [
          {
            geometry: {
              coordinates: coordinates,
              type: geoType
            },
            properties: properties
          }
        ]
      };
    }

    async function saveFeature(feature) {
      if (!currentMapId) {
        console.warn("No map selected for saving feature");
        return null;
      }

      try {
        console.log('üîÑ Saving feature:', feature);
        console.log('üîÑ To mapId:', currentMapId);
        
        const response = await fetch(`${apiBase}/api/v1/maps/${currentMapId}/layers`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { Authorization: `Bearer ${token}` } : {})
          },
          body: JSON.stringify(feature)
        });

        console.log('üì° Response status:', response.status);
        
        if (response.ok) {
          const savedFeature = await response.json();
          console.log('‚úÖ Feature saved successfully:', savedFeature);
          
          // Auto-save state after successful feature save
          saveMapState();
          
          return savedFeature;
        } else {
          const errorText = await response.text();
          console.error('‚ùå Failed to save feature:', response.status, errorText);
          return null;
        }
      } catch (error) {
        console.error('‚ùå Error saving feature:', error);
        return null;
      }
    }

    async function loadMapFeatures(mapId) {
      try {
        console.log(`üîÑ Loading features for mapId: ${mapId}`);
        const response = await fetch(`${apiBase}/api/v1/maps/${mapId}/features`, {
          headers: token ? { Authorization: `Bearer ${token}` } : {}
        });

        if (response.ok) {
          const features = await response.json();
          console.log('‚úÖ Loaded features:', features);
          console.log('Features count:', features.length);
          
          // Clear existing drawn items
          drawnItems.clearLayers();
          
          // Add features to map
          let loadedCount = 0;
          features.forEach(feature => {
            console.log('Processing feature:', feature);
            const layer = createLayerFromFeature(feature);
            if (layer) {
              drawnItems.addLayer(layer);
              layer._featureId = feature.featureId;
              loadedCount++;
              console.log(`‚úÖ Added feature to map: ${feature.name}`);
            } else {
              console.warn(`‚ùå Failed to create layer for feature: ${feature.name}`);
            }
          });
          
          console.log(`‚úÖ Total features loaded to map: ${loadedCount}/${features.length}`);
          document.getElementById('drawStatus').textContent = `Loaded ${loadedCount} saved features`;
          
          return features;
        } else {
          console.warn('‚ùå Failed to load features:', response.status);
          const errorText = await response.text();
          console.warn('Error response:', errorText);
          return [];
        }
      } catch (error) {
        console.error('‚ùå Error loading features:', error);
        return [];
      }
    }

    function createLayerFromFeature(feature) {
      try {
        const coords = JSON.parse(feature.coordinates);
        const style = feature.style ? JSON.parse(feature.style) : {};
        
        let layer = null;
        
        // Handle enum values (they come as strings from API)
        const geometryType = feature.geometryType || feature.GeometryType;
        const featureCategory = feature.featureCategory || feature.FeatureCategory;
        const annotationType = feature.annotationType || feature.AnnotationType;
        
        console.log(`Creating layer - Type: ${geometryType}, Category: ${featureCategory}, Annotation: ${annotationType}`);
        
        switch (geometryType.toLowerCase()) {
          case 'point':
            if (featureCategory.toLowerCase() === 'data') {
              // Pin
              layer = L.circleMarker([coords[1], coords[0]], { ...drawingStyles.pin, ...style });
            } else {
              // Marker/Text/Note/Link/Video
              const markerStyle = annotationType?.toLowerCase() === 'marker' ? drawingStyles.marker :
                                annotationType?.toLowerCase() === 'text' ? drawingStyles.text :
                                annotationType?.toLowerCase() === 'link' ? drawingStyles.link :
                                annotationType?.toLowerCase() === 'video' ? drawingStyles.video :
                                drawingStyles.note;
              layer = L.circleMarker([coords[1], coords[0]], { ...markerStyle, ...style });
            }
            break;
            
          case 'linestring':
            const lineCoords = coords.map(c => [c[1], c[0]]);
            // Check if it's a special annotation type
            if (featureCategory.toLowerCase() === 'annotation') {
              if (annotationType?.toLowerCase() === 'highlighter') {
                layer = L.polyline(lineCoords, { ...drawingStyles.highlighter, ...style });
              } else if (annotationType?.toLowerCase() === 'route') {
                layer = L.polyline(lineCoords, { ...drawingStyles.route, ...style });
              } else {
                layer = L.polyline(lineCoords, { ...drawingStyles.line, ...style });
              }
            } else {
              layer = L.polyline(lineCoords, { ...drawingStyles.line, ...style });
            }
            break;
            
          case 'polygon':
            const polygonCoords = coords[0].map(c => [c[1], c[0]]);
            layer = L.polygon(polygonCoords, { ...drawingStyles.polygon, ...style });
            break;
            
          case 'circle':
            const properties = feature.properties ? JSON.parse(feature.properties) : {};
            const radius = properties.radiusMeters || 1000;
            layer = L.circle([coords[1], coords[0]], { ...drawingStyles.circle, ...style, radius });
            break;
            
          default:
            console.warn(`Unknown geometry type: ${geometryType}`);
            return null;
        }
        
        if (layer && feature.name) {
          let popupContent = `<strong>${feature.name}</strong>`;
          if (feature.description) {
            popupContent += `<br/>${feature.description}`;
          }
          
          // Add special content for different annotation types
          if (feature.properties) {
            const props = JSON.parse(feature.properties);
            if (props.text) {
              popupContent += `<br/><em>"${props.text}"</em>`;
            }
            if (props.note) {
              popupContent += `<br/><em>"${props.note}"</em>`;
            }
            if (props.url) {
              popupContent = `<a href="${props.url}" target="_blank">${feature.name}</a>`;
            }
            if (props.videoUrl) {
              popupContent = `
                <div style="max-width: 300px;">
                  <strong>${feature.name}</strong><br/>
                  <a href="${props.videoUrl}" target="_blank">üé• Watch Video</a>
                </div>
              `;
            }
          }
          
          layer.bindPopup(popupContent);
        }
        
        return layer;
      } catch (error) {
        console.error('Error creating layer from feature:', error, feature);
        return null;
      }
    }

    function coordsToGeoJSON(layer) {
      if (layer instanceof L.CircleMarker || layer instanceof L.Marker) {
        const latlng = layer.getLatLng();
        return JSON.stringify([latlng.lng, latlng.lat]);
      } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        const coords = layer.getLatLngs().map(ll => [ll.lng, ll.lat]);
        return JSON.stringify(coords);
      } else if (layer instanceof L.Polygon) {
        const coords = layer.getLatLngs()[0].map(ll => [ll.lng, ll.lat]);
        return JSON.stringify([coords]);
      } else if (layer instanceof L.Circle) {
        const latlng = layer.getLatLng();
        return JSON.stringify([latlng.lng, latlng.lat]);
      }
      return "[]";
    }

    function getGeometryType(layer) {
      if (layer instanceof L.CircleMarker || layer instanceof L.Marker) {
        return 'Point';
      } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        return 'LineString';
      } else if (layer instanceof L.Polygon) {
        return 'Polygon';
      } else if (layer instanceof L.Circle) {
        return 'Circle';
      }
      return 'Point';
    }

    // ‚úÖ Load all templates on page load
    async function loadTemplateList() {
      try {
        const res = await fetch(`${apiBase}/api/v1/maps/templates`, {
          headers: token ? { Authorization: `Bearer ${token}` } : {}
        });

        if (!res.ok) {
          document.getElementById("templateSelect").innerHTML = 
            '<option value="">‚ùå Error loading templates</option>';
          return;
        }

        const data = await res.json();
        const templates = data.templates || [];
        
        const selectElement = document.getElementById("templateSelect");
        selectElement.innerHTML = '<option value="">-- Select Template --</option>';
        
        templates.forEach(template => {
          const option = document.createElement("option");
          option.value = template.templateId;
          option.textContent = `${template.templateName} (${template.totalFeatures} features)`;
          selectElement.appendChild(option);
        });

        // ‚úÖ Auto-select first template if available
        if (templates.length > 0) {
          selectElement.value = templates[0].templateId;
        }

      } catch (error) {
        console.error("Error loading templates:", error);
        document.getElementById("templateSelect").innerHTML = 
          '<option value="">‚ùå Error loading templates</option>';
      }
    }

    // ‚úÖ Handle template selection change
    document.getElementById("templateSelect").onchange = function() {
      const selectedId = this.value;
      if (selectedId) {
        document.getElementById("templateId").value = selectedId;
      }
    };

    document.getElementById("btnLoad").onclick = async () => {
      const id   = document.getElementById("templateId").value.trim();
      const msg  = document.getElementById("error");
      msg.textContent = "";

      if (!id) { msg.textContent = "Vui l√≤ng nh·∫≠p templateId"; return; }

      try {
        // ---- g·ªçi API: GET /api/v1/api/maps/templates/{templateId}
        const res = await fetch(`${apiBase}/api/v1/maps/templates/${id}`, {
          headers: token ? { Authorization: `Bearer ${token}` } : {}
        });

        if (!res.ok) {
          msg.textContent = `API error ${res.status}`;
          return;
        }
        const data = await res.json();
        console.log("API Response:", data); // Debug log

        // ‚úÖ L·∫•y template t·ª´ response structure m·ªõi
        const template = data.template;
        if (!template) {
          msg.textContent = "Template not found in response";
          return;
        }
        
        // ‚úÖ Create a new map instance from template for drawing features
        await createMapFromTemplate(template.templateId, template.templateName);
        currentLayerId = template.layers && template.layers.length > 0 ? template.layers[0].layerId : null;
        
        console.log('üó∫Ô∏è Map prepared for drawing:');
        console.log('  - MapId:', currentMapId);
        console.log('  - LayerId:', currentLayerId);
        console.log('  - Template:', template.templateName);

        // ‚úÖ Hi·ªÉn th·ªã th√¥ng tin template
        document.title = `MapTemplate Viewer - ${template.templateName}`;
        
        // ‚úÖ Clear layer c≈©
        if (window._allLayers) {
          window._allLayers.forEach(layer => map.removeLayer(layer));
          window._allLayers = [];
        } else {
          window._allLayers = [];
        }

        // ‚úÖ Load v√† hi·ªÉn th·ªã t·ª´ng layer v·ªõi GeoJSON data th·ª±c t·∫ø
        if (template.layers && template.layers.length > 0) {
          let layersLoaded = 0;
          const totalLayers = template.layers.length;
          
          msg.textContent = `Loading ${totalLayers} layers...`;
          
          for (const layerInfo of template.layers) {
            try {
              // G·ªçi API ƒë·ªÉ l·∫•y layer data
              const layerRes = await fetch(`${apiBase}/api/v1/maps/templates/${template.templateId}/layers/${layerInfo.layerId}/data`, {
                headers: token ? { Authorization: `Bearer ${token}` } : {}
              });

              if (layerRes.ok) {
                const layerData = await layerRes.json();
                const geoJsonData = JSON.parse(layerData.layerData);

                // ‚úÖ Parse layer style n·∫øu c√≥
                let layerStyle = polygonStyle;
                if (layerInfo.layerStyle) {
                  try {
                    const customStyle = JSON.parse(layerInfo.layerStyle);
                    layerStyle = { ...polygonStyle, ...customStyle };
                  } catch (e) {
                    console.warn("Invalid layer style, using default:", e);
                  }
                }

                // ‚úÖ T·∫°o layer v·ªõi data th·ª±c t·∫ø
                const geoLayer = L.geoJSON(geoJsonData, {
                  style: layerStyle,
                  onEachFeature: function(feature, layer) {
                    // Th√™m popup v·ªõi th√¥ng tin feature
                    if (feature.properties) {
                      const popupContent = Object.entries(feature.properties)
                        .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                        .join('<br/>');
                      layer.bindPopup(`
                        <div style="max-width: 300px;">
                          <h4>${layerInfo.layerName}</h4>
                          ${popupContent}
                        </div>
                      `);
                    }
                  }
                }).addTo(map);

                window._allLayers.push(geoLayer);
                layersLoaded++;

                // ‚úÖ Fit bounds khi load layer ƒë·∫ßu ti√™n
                if (layersLoaded === 1) {
                  map.fitBounds(geoLayer.getBounds());
                }

                console.log(`‚úÖ Loaded layer: ${layerInfo.layerName} (${layerInfo.featureCount} features)`);
              } else {
                console.warn(`‚ùå Failed to load layer ${layerInfo.layerId}:`, layerRes.status);
              }
            } catch (e) {
              console.error(`‚ùå Error loading layer ${layerInfo.layerId}:`, e);
            }
          }

          msg.style.color = "#28a745";
          msg.textContent = `‚úÖ Loaded: ${template.templateName} (${layersLoaded}/${totalLayers} layers, ${template.totalFeatures} features)`;
          
          // ‚úÖ Load existing user-drawn features
          await loadMapFeatures(currentMapId);
        } else {
          // ‚úÖ Fallback: Hi·ªÉn th·ªã bounds n·∫øu kh√¥ng c√≥ layers
          if (template.defaultBounds) {
            const boundsGeoJson = JSON.parse(template.defaultBounds);
            const boundsLayer = L.geoJSON(boundsGeoJson, { style: polygonStyle }).addTo(map);
            window._allLayers.push(boundsLayer);
            map.fitBounds(boundsLayer.getBounds());
            
            msg.style.color = "#ffc107";
            msg.textContent = `‚ö†Ô∏è No layers found, showing bounds only`;
          } else {
            msg.textContent = "No map data available";
            return;
          }
        }

        // ‚úÖ Hi·ªÉn th·ªã popup v·ªõi th√¥ng tin template (sau khi ƒë√£ load layers)
        if (window._allLayers.length > 0) {
          const center = map.getCenter();
          L.popup()
            .setLatLng(center)
            .setContent(`
              <div style="min-width: 200px;">
                <h4 style="margin: 0 0 8px 0;">${template.templateName}</h4>
                <p style="margin: 4px 0; color: #666;">${template.description || 'No description'}</p>
                <div style="font-size: 0.9em; color: #007bff;">
                  <strong>üìä Stats:</strong><br/>
                  ‚Ä¢ ${template.totalLayers} layers<br/>
                  ‚Ä¢ ${template.totalFeatures} features<br/>
                  ‚Ä¢ Category: ${template.category}<br/>
                  ‚Ä¢ Created: ${new Date(template.createdAt).toLocaleDateString()}
                </div>
                ${template.layers ? `
                  <div style="margin-top: 8px; font-size: 0.85em;">
                    <strong>üó∫Ô∏è Layers:</strong><br/>
                    ${template.layers.map(layer => 
                      `‚Ä¢ ${layer.layerName} (${layer.featureCount || 0} features)`
                    ).join('<br/>')}
                  </div>
                ` : ''}
              </div>
            `)
            .openOn(map);
        }

      } catch (e) {
        console.error("Error:", e);
        msg.textContent = `Error: ${e.message}`;
      }
    };

    // Drawing Event Handlers
    function setDrawingMode(mode) {
      // Clear active state from all buttons
      document.querySelectorAll('#drawingPanel button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      drawingMode = mode;
      
      if (mode) {
        document.getElementById(`draw${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
        document.getElementById('drawStatus').textContent = `Click to draw ${mode}`;
        map.getContainer().style.cursor = 'crosshair';
      } else {
        document.getElementById('drawStatus').textContent = 'Ready to draw';
        map.getContainer().style.cursor = '';
      }
    }

    // Map click handler for drawing
    map.on('click', async function(e) {
      if (!drawingMode || !currentMapId) return;
      
      const latlng = e.latlng;
      let layer = null;
      let feature = null;
      
      switch (drawingMode) {
        case 'point':
          layer = L.circleMarker(latlng, drawingStyles.pin);
          feature = formatFeatureData(layer, 'Pin', 'Point');
          break;
          
        case 'marker':
          layer = L.circleMarker(latlng, drawingStyles.marker);
          feature = formatFeatureData(layer, 'Marker', 'Point');
          break;
          
        case 'text':
          const text = prompt('Enter text:') || 'Text';
          layer = L.circleMarker(latlng, drawingStyles.text);
          layer.bindPopup(text);
          feature = formatFeatureData(layer, text, 'Point', { text: text });
          break;
          
        case 'note':
          const note = prompt('Enter note:') || 'Note';
          layer = L.circleMarker(latlng, drawingStyles.note);
          layer.bindPopup(note);
          feature = formatFeatureData(layer, 'Note', 'Point', { note: note });
          break;
      }
      
      if (layer && feature) {
        drawnItems.addLayer(layer);
        
        // Save to API
        const saved = await saveFeature(feature);
        if (saved) {
          layer._featureId = saved.id || saved.featureId || saved.feature_id;
          document.getElementById('drawStatus').textContent = `‚úÖ ${feature.name} saved`;
        }
        
        setDrawingMode(null); // Reset drawing mode
      }
    });

    // Button event listeners
    document.getElementById('drawPoint').onclick = () => setDrawingMode('point');
    document.getElementById('drawMarker').onclick = () => setDrawingMode('marker');
    document.getElementById('drawText').onclick = () => setDrawingMode('text');
    document.getElementById('drawNote').onclick = () => setDrawingMode('note');
    document.getElementById('drawLink').onclick = () => setDrawingMode('link');
    document.getElementById('drawVideo').onclick = () => setDrawingMode('video');
    
    // Line and Polygon drawing (more complex)
    let isDrawingLine = false;
    let isDrawingPolygon = false;
    let currentPath = [];
    let tempPolyline = null;
    let tempPolygon = null;

    document.getElementById('drawLine').onclick = function() {
      if (isDrawingLine) {
        // Finish line
        finishLineDrawing();
      } else {
        // Start line
        startLineDrawing();
      }
    };

    document.getElementById('drawPolygon').onclick = function() {
      if (isDrawingPolygon) {
        // Finish polygon
        finishPolygonDrawing();
      } else {
        // Start polygon
        startPolygonDrawing();
      }
    };

    // Highlighter (free drawing) - Toggle mode
    document.getElementById('drawHighlighter').onclick = function() {
      if (isDrawingHighlighter) {
        // Stop highlighter mode
        resetHighlighterDrawing();
      } else {
        // Start highlighter mode
        startHighlighterDrawing();
      }
    };

    // Route drawing
    document.getElementById('drawRoute').onclick = function() {
      if (isDrawingRoute) {
        // Finish route
        finishRouteDrawing();
      } else {
        // Start route
        startRouteDrawing();
      }
    };

    function startLineDrawing() {
      isDrawingLine = true;
      currentPath = [];
      setDrawingMode(null);
      document.getElementById('drawLine').classList.add('active');
      document.getElementById('drawStatus').textContent = 'Click points to draw line. Click Line button again to finish.';
      map.getContainer().style.cursor = 'crosshair';
    }

    function startPolygonDrawing() {
      isDrawingPolygon = true;
      currentPath = [];
      setDrawingMode(null);
      document.getElementById('drawPolygon').classList.add('active');
      document.getElementById('drawStatus').textContent = 'Click points to draw polygon. Click Polygon button again to finish.';
      map.getContainer().style.cursor = 'crosshair';
    }

    async function finishLineDrawing() {
      if (currentPath.length >= 2) {
        if (tempPolyline) map.removeLayer(tempPolyline);
        
        const line = L.polyline(currentPath, drawingStyles.line);
        drawnItems.addLayer(line);
        
        const feature = formatFeatureData(line, 'Line', 'LineString');
        
        const saved = await saveFeature(feature);
        if (saved) {
          line._featureId = saved.id || saved.featureId || saved.feature_id;
          document.getElementById('drawStatus').textContent = '‚úÖ Line saved';
        }
      }
      
      resetLineDrawing();
    }

    async function finishPolygonDrawing() {
      if (currentPath.length >= 3) {
        if (tempPolygon) map.removeLayer(tempPolygon);
        
        const polygon = L.polygon(currentPath, drawingStyles.polygon);
        drawnItems.addLayer(polygon);
        
        const feature = formatFeatureData(polygon, 'Polygon', 'Polygon');
        
        const saved = await saveFeature(feature);
        if (saved) {
          polygon._featureId = saved.id || saved.featureId || saved.feature_id;
          document.getElementById('drawStatus').textContent = '‚úÖ Polygon saved';
        }
      }
      
      resetPolygonDrawing();
    }

    function resetLineDrawing() {
      isDrawingLine = false;
      currentPath = [];
      if (tempPolyline) {
        map.removeLayer(tempPolyline);
        tempPolyline = null;
      }
      document.getElementById('drawLine').classList.remove('active');
      document.getElementById('drawStatus').textContent = 'Ready to draw';
      map.getContainer().style.cursor = '';
    }

    function resetPolygonDrawing() {
      isDrawingPolygon = false;
      currentPath = [];
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
        tempPolygon = null;
      }
      document.getElementById('drawPolygon').classList.remove('active');
      document.getElementById('drawStatus').textContent = 'Ready to draw';
      map.getContainer().style.cursor = '';
    }

    // Highlighter functions
    function startHighlighterDrawing() {
      isDrawingHighlighter = true;
      currentFreePath = [];
      setDrawingMode(null);
      document.getElementById('drawHighlighter').classList.add('active');
      document.getElementById('drawStatus').textContent = 'üñçÔ∏è Highlighter mode: Hold and drag to draw. Each stroke saves automatically. Click Highlighter to exit.';
      map.getContainer().style.cursor = 'crosshair';
      
      // Enable drag drawing
      map.dragging.disable();
    }

    function startRouteDrawing() {
      isDrawingRoute = true;
      currentFreePath = [];
      setDrawingMode(null);
      document.getElementById('drawRoute').classList.add('active');
      document.getElementById('drawStatus').textContent = 'Click points to draw route. Click Route button again to finish.';
      map.getContainer().style.cursor = 'crosshair';
    }

    async function finishHighlighterDrawing() {
      if (currentFreePath.length >= 2) {
        if (tempFreeLine) map.removeLayer(tempFreeLine);
        
        const highlighter = L.polyline(currentFreePath, drawingStyles.highlighter);
        drawnItems.addLayer(highlighter);
        
        const feature = formatFeatureData(highlighter, 'Highlighter', 'LineString');
        
        const saved = await saveFeature(feature);
        if (saved) {
          highlighter._featureId = saved.id || saved.featureId || saved.feature_id;
          document.getElementById('drawStatus').textContent = '‚úÖ Highlighter saved';
        }
      }
      
      resetHighlighterDrawing();
    }

    async function finishRouteDrawing() {
      if (currentFreePath.length >= 2) {
        if (tempFreeLine) map.removeLayer(tempFreeLine);
        
        const route = L.polyline(currentFreePath, drawingStyles.route);
        drawnItems.addLayer(route);
        
        const feature = formatFeatureData(route, 'Route', 'LineString');
        
        const saved = await saveFeature(feature);
        if (saved) {
          route._featureId = saved.id || saved.featureId || saved.feature_id;
          document.getElementById('drawStatus').textContent = '‚úÖ Route saved';
        }
      }
      
      resetRouteDrawing();
    }

    function resetHighlighterDrawing() {
      isDrawingHighlighter = false;
      currentFreePath = [];
      if (tempFreeLine) {
        map.removeLayer(tempFreeLine);
        tempFreeLine = null;
      }
      document.getElementById('drawHighlighter').classList.remove('active');
      document.getElementById('drawStatus').textContent = 'Ready to draw';
      map.getContainer().style.cursor = '';
      map.dragging.enable();
    }

    function resetRouteDrawing() {
      isDrawingRoute = false;
      currentFreePath = [];
      if (tempFreeLine) {
        map.removeLayer(tempFreeLine);
        tempFreeLine = null;
      }
      document.getElementById('drawRoute').classList.remove('active');
      document.getElementById('drawStatus').textContent = 'Ready to draw';
      map.getContainer().style.cursor = '';
    }

    // Enhanced map click handler
    map.off('click'); // Remove previous handler
    map.on('click', async function(e) {
      const latlng = e.latlng;
      
      // Handle route drawing (click-based)
      if (isDrawingRoute) {
        currentFreePath.push(latlng);
        
        if (tempFreeLine) map.removeLayer(tempFreeLine);
        tempFreeLine = L.polyline(currentFreePath, { ...drawingStyles.route, opacity: 0.5 });
        map.addLayer(tempFreeLine);
        
        document.getElementById('drawStatus').textContent = `Route: ${currentFreePath.length} points. Click Route button to finish.`;
        return;
      }
      
      // Handle line drawing
      if (isDrawingLine) {
        currentPath.push(latlng);
        
        if (tempPolyline) map.removeLayer(tempPolyline);
        tempPolyline = L.polyline(currentPath, { ...drawingStyles.line, opacity: 0.5 });
        map.addLayer(tempPolyline);
        
        document.getElementById('drawStatus').textContent = `Line: ${currentPath.length} points. Click Line button to finish.`;
        return;
      }
      
      // Handle polygon drawing
      if (isDrawingPolygon) {
        currentPath.push(latlng);
        
        if (tempPolygon) map.removeLayer(tempPolygon);
        if (currentPath.length >= 3) {
          tempPolygon = L.polygon(currentPath, { ...drawingStyles.polygon, opacity: 0.5 });
          map.addLayer(tempPolygon);
        } else if (currentPath.length >= 2) {
          tempPolyline = L.polyline(currentPath, { ...drawingStyles.polygon, opacity: 0.5 });
          map.addLayer(tempPolyline);
        }
        
        document.getElementById('drawStatus').textContent = `Polygon: ${currentPath.length} points. Click Polygon button to finish.`;
        return;
      }
      
      // Handle point-based drawing
      if (!drawingMode || !currentMapId) return;
      
      let layer = null;
      let feature = null;
      
      switch (drawingMode) {
        case 'point':
          layer = L.circleMarker(latlng, drawingStyles.pin);
          feature = formatFeatureData(layer, 'Pin', 'Point');
          break;
          
        case 'marker':
          layer = L.circleMarker(latlng, drawingStyles.marker);
          feature = formatFeatureData(layer, 'Marker', 'Point');
          break;
          
        case 'text':
          const text = prompt('Enter text:') || 'Text';
          layer = L.circleMarker(latlng, drawingStyles.text);
          layer.bindPopup(text);
          feature = formatFeatureData(layer, text, 'Point', { text: text });
          break;
          
        case 'note':
          const note = prompt('Enter note:') || 'Note';
          layer = L.circleMarker(latlng, drawingStyles.note);
          layer.bindPopup(note);
          feature = formatFeatureData(layer, 'Note', 'Point', { note: note });
          break;
          
        case 'circle':
          const radius = parseFloat(prompt('Enter radius in meters:')) || 1000;
          layer = L.circle(latlng, { ...drawingStyles.circle, radius: radius });
          feature = formatFeatureData(layer, 'Circle', 'Point', { radiusMeters: radius });
          break;
          
        case 'link':
          const url = prompt('Enter URL:') || 'https://example.com';
          const linkName = prompt('Enter link name:') || 'Link';
          layer = L.circleMarker(latlng, drawingStyles.link);
          layer.bindPopup(`<a href="${url}" target="_blank">${linkName}</a>`);
          feature = formatFeatureData(layer, linkName, 'Point', { url: url });
          break;
          
        case 'video':
          const videoUrl = prompt('Enter video URL (YouTube, Vimeo, etc.):') || 'https://youtube.com/watch?v=...';
          const videoTitle = prompt('Enter video title:') || 'Video';
          layer = L.circleMarker(latlng, drawingStyles.video);
          layer.bindPopup(`
            <div style="max-width: 300px;">
              <strong>${videoTitle}</strong><br/>
              <a href="${videoUrl}" target="_blank">üé• Watch Video</a>
            </div>
          `);
          feature = formatFeatureData(layer, videoTitle, 'Point', { videoUrl: videoUrl });
          break;
      }
      
      if (layer && feature) {
        drawnItems.addLayer(layer);
        
        // Save to API
        const saved = await saveFeature(feature);
        if (saved) {
          layer._featureId = saved.id || saved.featureId || saved.feature_id;
          document.getElementById('drawStatus').textContent = `‚úÖ ${feature.name} saved`;
        }
        
        setDrawingMode(null); // Reset drawing mode
      }
    });

    // Circle drawing
    document.getElementById('drawCircle').onclick = () => setDrawingMode('circle');

    // Clear all features
    document.getElementById('clearAll').onclick = function() {
      if (confirm('Clear all drawn features?')) {
        drawnItems.clearLayers();
        resetLineDrawing();
        resetPolygonDrawing();
        resetHighlighterDrawing();
        resetRouteDrawing();
        document.getElementById('drawStatus').textContent = 'All features cleared';
      }
    };

    // Mouse events for highlighter free drawing
    let isMouseDown = false;
    
    map.on('mousedown', function(e) {
      if (isDrawingHighlighter) {
        isMouseDown = true;
        currentFreePath = [e.latlng];
        
        if (tempFreeLine) map.removeLayer(tempFreeLine);
        tempFreeLine = L.polyline(currentFreePath, { ...drawingStyles.highlighter, opacity: 0.7 });
        map.addLayer(tempFreeLine);
      }
    });
    
    map.on('mousemove', function(e) {
      if (isDrawingHighlighter && isMouseDown) {
        currentFreePath.push(e.latlng);
        
        if (tempFreeLine) {
          tempFreeLine.addLatLng(e.latlng);
        }
        
        // Limit path length to prevent performance issues
        if (currentFreePath.length > 500) {
          currentFreePath.shift();
        }
      }
    });
    
    map.on('mouseup', async function(e) {
      if (isDrawingHighlighter && isMouseDown) {
        isMouseDown = false;
        
        // Auto-save highlighter after drawing
        if (currentFreePath.length >= 2) {
          const highlighter = L.polyline(currentFreePath, drawingStyles.highlighter);
          drawnItems.addLayer(highlighter);
          
          const feature = formatFeatureData(highlighter, 'Highlighter', 'LineString');
          
          // Remove temp line and save
          if (tempFreeLine) map.removeLayer(tempFreeLine);
          
          const saved = await saveFeature(feature);
          if (saved) {
            highlighter._featureId = saved.id || saved.featureId || saved.feature_id;
            document.getElementById('drawStatus').textContent = '‚úÖ Highlighter saved automatically';
            console.log('‚úÖ Highlighter auto-saved:', saved);
          } else {
            document.getElementById('drawStatus').textContent = '‚ùå Failed to save highlighter';
          }
          
          // Reset for next drawing
          currentFreePath = [];
          tempFreeLine = null;
        } else {
          document.getElementById('drawStatus').textContent = 'Highlighter too short, try drawing a longer line';
        }
      }
    });

    // Button event handlers
    document.getElementById('btnLoadMap').onclick = async () => {
      const mapId = document.getElementById('mapId').value.trim();
      const msg = document.getElementById('error');
      msg.textContent = "";

      if (!mapId) { 
        msg.textContent = "Please enter a Map ID"; 
        return; 
      }

      await loadMapById(mapId);
    };

    document.getElementById('btnSaveState').onclick = () => {
      saveMapState();
      document.getElementById('error').style.color = '#28a745';
      document.getElementById('error').textContent = 'üíæ State saved to browser storage';
    };

    document.getElementById('btnClearState').onclick = () => {
      if (confirm('Clear saved state? This will remove the saved map information.')) {
        clearMapState();
        document.getElementById('error').style.color = '#ffc107';
        document.getElementById('error').textContent = 'üóëÔ∏è State cleared';
      }
    };

    // Auto-restore state on page load
    async function autoRestoreState() {
      const savedState = loadMapState();
      if (savedState && savedState.currentMapId) {
        console.log('üîÑ Auto-restoring previous state...');
        document.getElementById('mapId').value = savedState.currentMapId;
        
        // Try to reload the previous map
        const restored = await loadMapById(savedState.currentMapId);
        if (restored) {
          document.getElementById('error').style.color = '#28a745';
          document.getElementById('error').textContent = 'üîÑ Previous session restored automatically';
        }
      }
    }

    // Token management
    document.getElementById('btnSetToken').onclick = () => {
      const inputToken = document.getElementById('tokenInput').value.trim();
      if (inputToken) {
        token = inputToken;
        localStorage.setItem('apiToken', token);
        document.getElementById('error').style.color = '#28a745';
        document.getElementById('error').textContent = '‚úÖ Token saved successfully';
        console.log('üîë Token updated');
      } else {
        document.getElementById('error').style.color = '#dc3545';
        document.getElementById('error').textContent = '‚ùå Please enter a token';
      }
    };

    // Load saved token on page load
    if (token) {
      document.getElementById('tokenInput').value = token;
    }

    // ‚úÖ Load templates and restore state when page loads
    window.onload = async function() {
      await loadTemplateList();
      await autoRestoreState();
    };
  </script>
</body>
</html>